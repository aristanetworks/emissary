# syntax = docker/dockerfile:1.3

###
# This dockerfile builds all the source code and docker images for the
# edge stack.
##

###
# How it works.
##
# We use a multi-stage build to create optimized release images:
# 1. golang stage: Builds Go binaries
# 2. python-builder stage: Uses UV to build Python dependencies
# 3. ambassador stage: Final optimized image with binaries and Python packages

# This argument controls the base image that is used for the release
# containers.
ARG base="i-forgot-to-set-build-arg-base"

########################################
# The envoy stage
########################################

FROM envoyproxy/envoy:distroless-v1.35.8 as envoy

########################################
# The golang build stage
########################################

FROM golang:1.23.3-alpine3.20 as golang

WORKDIR /go

# Install git for go build (if needed by vendored dependencies)
RUN apk add --no-cache git

# Build the golang binaries
ADD api api
ADD cmd cmd
ADD pkg pkg
ADD vendor vendor
ADD go.mod go.mod
ADD go.sum go.sum

RUN --mount=type=cache,target=/root/.cache/go-build \
    mkdir -p /go/bin && \
    time go build -mod=vendor -o /go/bin/ ./cmd/...

########################################
# The Python build stage
########################################

FROM python:3.11-alpine3.20 as python-builder

WORKDIR /buildroot

# Copy UV from official distroless image
COPY --from=ghcr.io/astral-sh/uv:latest /uv /uvx /bin/

# Set UV environment variables for optimization
ENV UV_COMPILE_BYTECODE=1 \
    UV_LINK_MODE=copy \
    UV_PROJECT_ENVIRONMENT=/buildroot/.venv

# Copy Python project files for dependency resolution
# Copying lock file and pyproject.toml first for better layer caching
ADD python/pyproject.toml python/uv.lock python/

# Install dependencies (without project code) to leverage Docker layer caching
RUN --mount=type=cache,target=/root/.cache/uv \
    cd python && \
    uv sync --locked --no-install-project --no-dev

# Now copy the rest of the Python project and install it
# This includes ambassador.version which is generated by the Makefile before docker build
ADD python python
RUN --mount=type=cache,target=/root/.cache/uv \
    cd python && \
    uv sync --locked --no-dev

########################################
# The artifacts build stage
########################################

FROM alpine:3.20 as artifacts

WORKDIR /buildroot/ambassador

# Install bash and sudo (needed by post-compile.sh)
RUN apk add --no-cache bash sudo

ENV PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/buildroot/bin

# Copy in the golang binaries
COPY --from=golang /go/bin/* /buildroot/bin/

# Run post-compile.sh
ADD build-aux build-aux
ADD post-compile.sh post-compile.sh
RUN bash post-compile.sh

# XXX: this will go away
RUN mkdir -p /ambassador/sidecars

# These will be extracted into the optimized image later
ADD manifests/emissary/emissary-crds.yaml.in manifests/emissary/emissary-crds.yaml

########################################
# The optimized images
########################################

FROM ${base} as ambassador

# Always have an "ambassador" user as UID 8888. This is what we recommend
# people run as. (Note that the "-D" actually leaves the password locked.)
RUN adduser ambassador -u 8888 -G root -D -H -s /bin/false

# External stuff that should change infrequently
# We install python3 without pinning version since we use whatever comes with the base Alpine
RUN apk --no-cache add bash curl python3 libcap htop
RUN apk upgrade --no-cache

# Our envoy. The capabilities here grant the wrapper the ability to use the
# cap_net_bind_service cap and for Envoy to inherit it.
COPY --from=envoy /usr/local/bin/envoy /usr/local/bin/envoy
RUN setcap cap_net_bind_service=ei /usr/local/bin/envoy

# Our Go binaries. See envoy section for setcap info.
COPY --from=artifacts /opt/ambassador /opt/ambassador
RUN ln -s /opt/ambassador/bin/* /usr/local/bin/
RUN setcap cap_net_bind_service=p /opt/ambassador/bin/wrapper

# Copy Python virtual environment and source code from python-builder
# We use editable install, so the .venv references the python source directory
COPY --from=python-builder /buildroot/.venv /buildroot/.venv
COPY --from=python-builder /buildroot/python /buildroot/ambassador/python

# Ensure Python finds the packages in .venv
ENV PATH="/buildroot/.venv/bin:$PATH" \
    VIRTUAL_ENV="/buildroot/.venv"

# Delete some things that cause problems for security scanners.
RUN find / \( -iname '*sqlite*' -o -iname '*gdbm*' -o -iname '*smtplib*' -o -iname '*piptools*' -o -iname '*pip_tools*' -o -iname '*ensurepip*' \) -exec rm -rf -- '{}' \+

# Configuration
COPY --from=artifacts /ambassador /ambassador

# Fix permissions to allow correctly running as a non root user
# XXX: We could combine everything into one tree in the builder, fix permissions
# there, and then a use single COPY to get everything and avoid duplicating the
# (small amount of) data in a new layer for this RUN.
RUN chgrp -R 0 /ambassador && \
    chmod -R u+x /ambassador && \
    chmod -R g=u /ambassador /etc/passwd

WORKDIR /ambassador

# Force the HOME environment variable to a directory that'll always be writeable.
# We use /tmp/ambassador for this, and make sure it exists in our entrypoint,
# because trying to create it here in the Dockerfile doesn't always work very
# well in the face of situations like KAT volume-mounting /tmp/ambassador or
# the like.
ENV HOME=/tmp/ambassador

ENTRYPOINT [ "bash", "/buildroot/ambassador/python/entrypoint.sh" ]
